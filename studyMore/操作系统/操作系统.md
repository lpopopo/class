

# 操作系统

## 第一章

### 操作系统的基本特性

#### **并发与并行**

并行是指两个或者多个事件在同一时刻发生

并发是指两个或多个事件在同一时间间隔发生，它们并非是真正的同时运行，而是由于进程得切换速度足够的快保证人无法察觉到变化。

- **进程**

  所谓进程，是指在操作系统中能独立运行并作为资源分配的基本单位，他是由一组机器指令，数据和堆栈等组成的，是一个独立运行的活动实体。**多个进程之间可以并发执行和交换信息**。

- **共享**

​       操作系统中的共享与一般情况下的共享不相同，操作系统中的共享被称为资源复用，是指系统中的资源可供内存中多个并发执行的进程共同使用。这里在宏观上既限定了时间(进程在内存期间)，也限定了地点(内存)。对于这种资源共享方式，其管理要复杂很多。因为系统中的资源远小于多道程序需求的总和，会形成他们对共享资源的争夺。所以，操作系统必须对资源进行妥善的管理。

#### **互斥共享方式**

当进程A要访问某资源是时，必须先提出请求，若此时该资源是空闲的，系统便可以将之分配给进程A使用。此后若在有其他进程对他进行访问，再A进程未结束之前必须进行等待。仅当A进程访问完并释放系统资源后，才允许另一进程对资源进行访问。

把这一段时间内只允许一个进程访问的资源称为临界资源(或独占资源)。系统中大多数物理设备，以及栈，变量和表格都属于临界资源。

#### **同时访问方式**

这里的同时，在单处理机环境下是宏观意义的，而在微观上，这些进程对该资源的访问是交替进行的。典型的可供多个进程“同时”访问的资源就是磁盘设备。

并发和共享是多用户(多任务)OS的两个最基本的特征。它们又是互为存在的条件。资源共享是并行的条件，若系统没有并发就不会存在资源共享，而如果系统没有对资源共享进行有效的管理，也必然影响到并发执行的程度。

- **虚拟**

  在OS中，把通过某种技术把一个物理实体变为若干个逻辑上的对应物的功能称为"虚拟"

  - **时分复用技术**

    时分复用技术提高资源利用率的根本原因在于，他利用某设备为一用户空闲的时间，又转去服务另外的用户，设备得到充分利用。

    - **虚拟处理机技术**

      利用多道程序设计技术，为每一个程序建立至少一个进程，让多道程序并发进行。

    - **虚拟设备技术**

        将一台物理的IO设备虚拟为多台逻辑上的IO设备，并允许每一个用户占用一台逻辑上的IO设备。

  
  - **空分复用技术**
    空分复用技术则是利用存储器的空闲空间分区链存放和运行其他的多道程序，以此来提高效率。
    单纯的空分复用技术只能提升内存的利用率，并不能在逻辑上扩大存储器容量的功能，这还必须引入虚拟存储技术才能达到目的。虚拟存储技术在本质上是对内存的分时复用，即它可以通过分时复用的形式，使一道程序在远小于他的内存空间上运行。
  - **异步**
    每次只允许一个进程执行，其余进程只能等待。

### 操作系统的主要功能

####   处理机管理功能

（

扩展：处理机与`cpu` :

处理机：处理机是计算机系统中存储程序和数据，并按照程序规定的步骤执行指令的部件,包括中央处理器`（cpu）`，主存储器,输入-输出接口   

`cpu` : 是一块超大规模的集成电路，是一台计算机的运算核心（Core）和控制核心（ Control Unit）。它的功能主要是解释计算机指令以及处理计算机软件中的数据.

）

在传统的多道程序系统中，处理机的分配和运行都是以进程为基本单位的，因而对处理机的管理可归结为对进程的管理。处理机管理的主要功能有：创建和撤销进程，对诸进程进行协调，实现进程之间的信息交换，以及按照一定算法把处理机发分配给进程。

- **进程控制**
  在多道程序的环境下为使作业能并发执行，必须为每道作业创建一个或多个进程，当进程运行结束时，还应当立即撤销进程，以便回收此进程占用的各类资源。在设置有线程的OS中，进程控制还应当包括为一个进程创建若干个线程，以提高系统的并发性。
  
- **进程同步**
  为使多个进程有条不紊的运行，系统中必须设置相应的进程同步机制。该机制的主要任务是对多个进程的运行进行协调。协调方式：
  1.进程互斥返回方式。
  2.进程同步方式：指在相互合作去完成共同任务的诸进程间，由同步机构对它们的执行次序加以协调。
  最简单的互斥方式是为每一个临界资源配置一把锁W，当锁打开时，进程可以对该临界资源进行访问，当锁关上时禁止进程访问临界资源。
  最常用的机制是信号量机制。
  
- **进程通信**
  当相互合作的进程处于同一计算机系统时，通常在它们之间采用直接通信方式，即由源进程利用发送命令的直接将消息挂在目标进程的消息队列上，以后由目标进程利用接受命令从消息队列中取出消息。
  
- **调度**
  在传统OS中，调度包括作业调度和进程调度两步
  (1)作业调度：(高级调度)
  作业调度的基本任务就是从后备队列中按照一定的算法选择出若干个作业，为他们分配所需的资源，在将在这些作业调入内存后，分别为他们建立进程，使他们都成为可能获得处理机的就绪进程，并将他们插入就绪队列中去。
  
  (2)内存调度：(中级调度)
  
  引入中级调度是为了提高内存利用率和系统吞吐量。为此， 应使那些暂时不能运行的进程，调至外存等待，把此时的进程状态称为挂起状态 。当它们己具备运行条件且内存又稍有空闲时，由中级调度来决定，把外存上的那些己具备运行条件的就绪进程， 再重新调入内存，并修改其状态为就绪状态 ，挂在就绪队列上等待
  
  (3)进程调度：(低级调度)
  进程调度的任务是从进程就绪队列中按照一定的算法选出一个进程，将处理机分配给他，并未他设置运行现场，使其投入执行。
  
  ![avatar](/home/ls/桌面/class/studyMore/操作系统/img/9300974-62f9a0da7697dfbe.png)



　#### 存储器管理功能

存储管理器应具有内存分配，回收，内存保护，地址映射和内存扩充等功能．

- 内存分配

  (1)为每一道程序分配内存空间，

  (2)提高存储器的利用效率，尽量减少不可用的内存空间(碎片)

  (3)允许正在运行运行的程序申请附加内存，以适应程序和数据动态增长的需要

- 内存分配的两种方式

  - 静态内存分配方式：即每个作业在作业装入是内存空间是确定的，在作业装入之后的整个运行后的期间不允许程序继续申请新的内存空间，也不允许作业在内存空间中＂移动＂.
  - 动态内存分配方式：即虽然每个作业在作业装入的时候内存空间是确定的，但作业在运行过程中申请新的内存空间，也允许作业在内存中移动．

- 内存保护

　　内存保护的主要的任务：

​         (1)确保用户的每道程序都在自己的内存空间中运行，彼此之间互不干扰．

　　(2)决不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其他用户程序中执行.

- 内存保护机制

  一种比较简单的方式就是设置两个界限寄存器，分别用于放在正在执行的程序的上界和下界．系统须对每条指令进行检查所访问的地址，若发生越界，便发出越界中断请求，已停止该程序运行．

- 地址映射

  在程序编译的过程中，其地址都是从０开始的，但是在真正的实际情况中，所有的地址不可能都是从０开始的，所以应当存在将程序的逻辑地址转化为预支相对应的物理地址．该功能应当在硬件支持下完成．

- 内存扩充

  内存扩充是使用虚拟技术使逻辑上内存得到扩充，而实际物理的内存并没有变化．

  - 内存扩充机制
    - 请求调入功能：系统允许在仅装入部分用户程序和数据的情况下，便能对程序进行运行，在运行过程中，若发现需要的数据和程序微装入内存中，可向OS发送请求，有OS将所需的程序和数据由磁盘调入内存中，以便后续需要．
    - 置换功能：即在调入所需的程序和数据是发现内存已满，此时可以将内存中部分暂时不用的的程序和数据放到硬盘中，腾出空间，以调入所需的程序和数据．

#### 设备管理功能

- 缓冲管理

  在I/O设备和CPU之间引入缓冲

  1. **可以有效的缓和I/O设备和CPU速度不匹配的矛盾,**

  2. **提高I/O 和CPU之间得并行 **:   

     CPU快速的将输出的数据写入到缓存区中，I/O设备可以根据自己的速度将数据写入到硬盘中，但是对于CPU而言，它的工作已将完成．可以进行其他的工作．

  　3.**解决处理单位与传输单位不一致问题**:

  ​        对与块设备而言，它的数据传输的单位必然是固定单位的数据块，比如一个扇区，但是对于进程而言，往往是以字节的形式进行读取．

  　　设备将块区域的数据读取到缓冲区，然后在以字节数的形式进行读取

  常见的缓冲机制：

  1.单缓冲机制，

  2.双缓冲机制，能实现双向同时传送数据，

  3.公用缓冲池机制，能供多个设备同时使用

  ![avatar](/home/ls/桌面/class/studyMore/操作系统/img/v2-2790da58b18f5f277540f4a35fae20ef_hd.jpg)

  

- 设备分配

  设备分配的基本任务就是根据用户进程的I/O请求，系统现有的资源情况以及按照某种设备分配策略，为其分配设备．若在I/O设备和CPU之间还存在这设备控制器和I/O通道，则还需为分配出去的设备分配相应的控制器和通道．系统中还应当设置设备控制表，控制器控制表的数据结构进行相关状态的记录，以实现系统的分配.在设备使用完后，应立即由系统回收．

- 设备处理: 又称为设备驱动程序,基本任务：实现CPU和设备控制器之间的通信，即由CPU向设备控制器发送I/O命令，启动I/O设备完成指定的I/O操作，反之，由CPU接受从控制器来的终端请求，并给予迅速的响应和相应的处理．

- I/O控制方式:

  - 　程序I/O方式　：即在处理机向控制器发出一条I/O指令启动输入设备输入数据时，要同时把状态寄存器中的忙/闲标志busy设置为1，然后便不断地循环测试busy，只有当其为0时，表示输入已经送入控制器的数据寄存器中，于是处理机将数据寄存器中的数据取出，送入内存指定单元中，这样便完成了一个字（符）的.
  - 　中断驱动I/O方式　：　当进程中的程序有I/O要求时，CPU会发信号通知相应的设备控制器，然后在继续返回执行相应任务．任务控制器接受信号之后，按要求控制指定的设备，待设备将数据写入寄存器后，由任务控制器进行请求通知CPU，CPU检查输入中是否有错，若没错，就将数据写入内存中．
  
  - 直接存储器访问`（DMA）I/O`控制方式１．数据传输的基本单位是数据块，即在CPU与I/O设备之间，每次传送至少一个数据块。２．所传送的数据是从设备直接送入内存的，或者相反。３．仅在传送一个或多个数据块的开始和结束时，需要CPU干预，整块数据的传送是在控制器的控制下完成的。
  
- `DMA`控制器由三部分组成，主机与`DMA`控制器的接口；`DMA`控制器与块设备的接口；I/O控制逻辑
  

![](/home/ls/桌面/class/studyMore/操作系统/img/616953-20160628173514952-543939858.png)

- １．２两种方式是以字节的方式就是从缓冲区进行读取的，一字节，一字节的进行，而块设备是以块为单位，CPU中断的频率高，３方法则直接以块单位进行
  

下面是三种不同方式的流程图：

![avatar](/home/ls/桌面/class/studyMore/操作系统/img/616953-20160628193955531-1354950266.png)



#### 文件管理功能

- 文件存储空间的管理
  
  为每个文件分配必要的外存空间，提高外存的利用率，进而提高文件系统的存，取速度．
  
  应此系统中应设置相应的数据结构，用来存储文件存储空间的使用情况
  
  还应具有对存储空间进行分配和回收的功能
  
- 目录管理
  
  目录管理还应当实现文件共享，只需要在外存上保留一份该共享文件的副本．
  
  提供快速的目录查询手段，以提高对文件检索的速度．
  
- 文件的读/写管理和保护
  
  (1)文件的读写管理：在进行文件读/写时，系统先根据用户给出的文件名进行检索文件目录，从未获取在外存中的位置．然后利用文件读/写指针进行读/写，完成读/写之后修改读/写指针,为下一次读/写做好准备.
  
  (2)文件保护:
  
  1.防止未经核准的用户存取文件
  
  2.防止冒名的用户存取文件
  
  3.防止以不正确的方式使用文件
  

  
### 操作系统与用户之间的接口

#### 用户接口

- 连接用户接口：为联机用户提供，有一组键盘操作命令即，命令解释程序组成．当用户在终端或控制台上键入一行命令之后，系统便转入命令解释程序，该该命令加以解释及执行．完成指令后系统返回终端或控制台．
  

  
- 脱机用户接口：也称批处理用户接口．即用户可以用作业控制语言`JCL`把需要对作业进行的控制和干预的命令事先写在说明书上，然后将他与作业一起提供给系统．当系统调度到该作业时，通过调用命令解释程序去对作业说明书上的命令逐条解释，直至遇到系统结束语时停止执行．

- 图形用户接口

#### 程序接口

程序接口是为了用户的程序能够访问到系统资源而设置的，是用户程序取得操作系统服务的唯一途径．



### 现代操作系统的新功能

#### 系统安全

- 认证技术：　用来确认用户的真实性．防止入侵者进行假冒和篡改
- 密码技术：　即系统中所需储存的数据和传输的数据进行加密．
- 访问控制技术：　
  - 通过用户存取权限的设置，可以限定用户只能访问被允许访问的资源＼
  - 通过文件属性的设置　，　比如设置文件对于其他用户为可读
- 反病毒技术：对于病毒的威胁就好的方法就是预防．

#### 网络的功能和服务

- 网络通信: 用在源主机和目标主机上面，实现无差错的数据传输．
- 资源管理：即对网络中的共享资源(硬件与软件)实施有效的管理，协调用户使用，保证数据的安全和一致性.
- 应用互操作：即在一个由若干个不同网络互联所构成的互联网络中，必须提供应用互操作功能，以实现信息的互通性和互用性.

#### 支持多媒体

- 接纳控制功能
- 实时调度
- 多媒体文件的存储



### OS结构设计

#### 传统操作系统结构

我们把早期的无结构的OS(第一代),模块化结构的(第二代), 分层式结构的(第三代) 都统称为传统结构的OS，而把微内核结构的OS称为现代结构的OS

- 无结构的操作系统 :早期的操作系统主要有一个人进行编写，注意力放在功能的实现和获得高的效率，致使操作系统内部既复杂又混乱．
- 模块结构OS:  
  - 模块化的基本概念 : 每个模块具有某方面的功能，并仔细规定好每个模块之间的接口，使每个模块之间能通过接口实现交互．
  - 模块独立性: 以下两个标准：
    - 内聚性: 模块内各部分联系的紧密程度，内聚性越高，模块独立性越强．
    - 耦合性：指模块间相互联系和互相影响的程度，耦合度越低，独立性越强．
  - 模块接口法的优缺点
    - 优点：
      - 提高OS设计的正确性，可理解性和可维护性
      - 增强OS的可适应性
      - 加速OS的开发过程
    - 缺点:
      - 对各模块的接口规定很难满足模块完成后的实际需求
      - 设计者必须做出一系列的决定，每一个决定必须建立在上一个的决定之上．
- 分城市结构OS
  - 基本概念：采用自底向上来铺设中间层
  - 优缺点：
    - 优点：
      - 易保证系统的正确性
      - 易扩充和易维护
    - 缺点
      - 系统效率降低

#### 客户/服务器模式简介

- 客户/服务器模式的由来,组成和类型
  - 客户/服务器系统主要由三部分组成
    - 客户机：平视它处理一些本地服务，也可以发行一个消息给服务器，以请求某型服务
    - 服务器：通常是一台规模较大的机器，在其上驻留有网络文件或数据库系统．
    - 网络系统：是用来连接所有客户机和服务器的，实现他们之间的通信和网络资源共享的系统
- 客户/服务器之间的交互
  - 客户发送请求信息：
  - 服务器接受信息：
  - 服务器回送信息
  - 客户机接受信息
- 客户/服务器模式的优点
  - 数据的分布式处理和存储
  - 便于集中管理
  - 灵活性和可扩展性
  - 易于改编应用软件
- 缺点
  - 不可靠性和瓶颈问题

####　微内核结构

- 基本概念: 为了提高操作系统的"正确性","灵活性","易维护性"和"可扩充性",大多采用的是基于客户/服务器模式的微内核

  - 足够小的内核

    微内核并非一个完整的内核，而是内核中最基本的部分，通常包含:

    - 与硬件紧密相连的部分
    - 一些较为基本的功能
    - 客户和服务器之间的通信

  - 基于客户/服务器模式:即将操作系统中的绝大多数的功能放在微内核外面的一组服务器(进程)中实现.相当于在本地跑服务，微内核通过请求相关的进程实现．

    - 优点:
      - 1.就是易于维护，相比于宏内核而言，微内核只需更新自己相关的模块即可完成OS的更新
      - 2.就是只有一个模块出现问题而不至于整个模块死掉，相比宏内核．
    - 缺点:
      - 1.进程间的通信需要时间和资源

  - 应用"机制与策略分离"原理

  - 采用面向对象的技术

- 微内核的基本功能

  - 进程(线程)的管理:由于采用的＂机制与策略分离＂，所以机制一般放在内核中，而策略被放在服务器上.进程通信，切换，线程调度，以及多处理器之间的同步登功能也被放在为内核中
  - 低级存储器管理
  - 中断和陷入处理：因为微内核将机制与策略分离，所以在此时微内核主要任务是捕获所有发生的中断的陷入事件．并进行相应的前期处理.　例如：进行中断现场保护，识别中断和陷入类型，然后将有关时间的信息转化为消息后，把他发给相关的服务器．由服务器进行后期的处理.

- 优点

  - 提高系统的可扩展性
  - 增强系统的可靠性
  - 可移植性强:适应和不同的硬件，应为大多数的服务是跑在服务器上的，所以与硬件无关
  - 提供了分布式系统的支持
  - 融入面向对象技术

- 缺点

  - 请求时更多的上下文切换

    - 原来的OS一般只需要进行两个上下文的切换，一次在执行系统调用后由用户态转为系统态，另一次是在系统完成用户请求的服务后，由系统态返回用户态
    - 在微内核中，由于客户机和服务器，服务器和服务器之间都是需要经过微内核,所以同样的请求至少需要四次上下文切换.

    ![](/home/ls/桌面/class/studyMore/操作系统/img/1427277-20190617222855861-909778725.png)



##　第二章  进程的描述与控制

### 前趋图和程序执行

#### 程序顺序执行时的特征

- 顺序性：指处理机严格按照程序所规定的顺序执行，即每一个操作必须在下一个操作前结束.
- 封闭性:指程序在封闭的环境下运行，即程序运行时独占全机资源，资源的状态(除初始状态外)只有本进程可以改变．程序一旦开始，其执行结果不受外界因素影响.
- 可再现性:只要程序执行环境和初始条件相同，当程序重复执行时，不论是一直执行还是"走走停停"，其执行结果都是一样的.

#### 程序并发执行

##### 程序并发执行的特征

- 间断性:　由于程序在并发的执行,共享系统资源，以及为完成一套任务而相互合作．导致并发程序之间有相互制约关系
- 失去封闭性：系统中的资源将为这些并发的程序进行共享．
- 不可再现性：由于失去封闭性，导致失去再现性．

### 进程的描述

#### 进程引进的原因

在上述中，由于程序的并发执行使程序失去了封闭性，并且具有了间断性．从而为使每个程序互相单独执行，而互不干扰,并对程序加以描述和控制．

进程控制块(PCB)：描述进程的基本情况和活动过程，进而控制和管理进程.

进程实体(又称进程映像): 由程序段，相关数据段和PCB构成 ,一般情况下我们将进程实体简称为进程

#### 进程的定义

- 进程是程序的一次执行
- 进程是一个程序及其数据在处理机上顺序执行是发生的活动
- 进程是具有独立功能的程序在一个数据集合上运行的结果，是系统进行资源分配和调度的一个独立单位

### 进程的特征

- 动态性：进程的实质是进程实体的执行过程
- 并发性：
- 独立性：指进程是一个能独立运行，独立获得资源并且能够独立接受调度的基本单位
- 异步性：按异步方式进行运行，即安各自独立的，不可预知的速度向前推进.

### 进程的基本状态即转换

#### 进程的三种基本状态

- 就绪状态：指进程已处于准备好运行的状态，即进程已经分配到除CPU以外的所有必要资源后，只要再获得CPU，就可以立即执行.
  - 就绪队列:如果系统中有许多处于就绪状态的进程，通常按一定的策略排成一个队列，这就是就绪队列
- 执行状态:指进程已经获得CPU，其程序正在执行.
- 阻塞状态：即正在执行的进程，由于某事件暂时无法继续执行的状态
  - 阻塞队列：在较大的系统中，为减小队列操作的开销，提高系统效率，根据阻塞原因不同，会设置多个阻塞队

#### 基本状态的装换

![](/home/ls/桌面/class/studyMore/操作系统/img/Ary4VP.png)

#### 挂起操作的引入

- 终端用户的需要 : 检查暂停程序
- 父进程请求:有时父进程想挂起子进程，以便考察修改子进程
- 负荷调节的需要　
- 操作系统的需要：以便检查运行中的资源使用或者协调各子进程间的活动

###　进程管理中的数据结构

#### 操作系统中用于管理控制的数据结构

![](/home/ls/桌面/class/studyMore/操作系统/img/20190802213946842_AAMNHW.jpg)

进程表又被称为PCB

#### 进程控制块PCB的作用

PCB的作用是是一个在多道程序环境下不能独立运行的程序(含数据块)成为一个能够独立运行的基本单位，一个能够与其他进程并发执行的进程.

- 作为独立运行基本单位的标志  ：系统通过PCB感知进程的存在　，PCB已成为进程存在的唯一标志.创建进程时为其建立一个PCB，在进程结束时回收PCB
- 能实现间断性的运行方式：在多道程序执行过程中，当前的程序被中断，他可以将CPU中的现场数据保存在PCB中，以便再次调入执行的时候，恢复现场数据．作为传统意义上的程序被中断的时候，因为无法恢复现场数据，也就不具有保护或保存现场的手段，也就没有再现性．
- 提供进程管理所需的信息：进程调度时，只能根据该进程PCB中记录的程序和数据在内存或外存中的始止指针，找到相应的程序和数据．访问文件系统和I/O设备时,也需要借助于PCB中的信息.
- 提供调度所需的信息：提供进程处于何种状态
- 实现与其他进程的同步与通信

#### 进程控制块的信息

- 进程标识符：唯一标识某个进程
  - 外部标识符：由创建者提供，通常有字母，数字组成，为了描述进程的家族关系，还应当设置父进程便是与子进程标识，此外还可以设置用户标识，以示进程的拥有者
  - 内部标识符：赋予每一个进程以个唯一的数字标识符，通常为进程的序号
- 处理机状态：处理机状态也称处理机的上下文，主要是由处理机的各种寄存器中的内容组成，其中包括：
  - 通用寄存器：用户程序可以访问，用来暂存信息
  - 指令计数器：存放了要访问的下一条指令的位置
  - 程序状态字`PSW`：包含状态信息
  - 用户指针栈：指每个用户进程都有一个或若干个与之相关的系统栈，用于存放过程和系统调用参数即调用地址
- 进程调度信息：
  - 进程状态
  - 进程优先级
  - 进程调度所需的其他信息，与所采用的进程调度算法有关
  - 事件：指进程由执行状态变为阻塞状态所等待发生的是事件，即阻塞原因
- 进程控制信息：
  - 程序和数据的地址
  - 进程同步和通信机制：如消息队列指针，信号量等
  - 资源清单：列出进程运行期间所需的全部资源(CPU)除外，另外还有一张已分配到该进程的资源清单
  - 链接指针：给出本进程所在队列中的下一个进程的PCB首地址

#### 进程控制块的组织方式

- 线性方式
- 连接方式
- 索引方式

### 进程控制

进程控制是进程管理最基本的功能，主要包括创建进程，终止已完成的进程．将因为发生异常而无法继续工作的进程至于阻塞状态，负责进程运行的的状态转换等功能. 进程控制一般是由OS的内核中的原语实现的

####　操作系统的内核

为了防止OS本身即关键数据如(PCB等)遭到应用程序破坏，通常将处理机的执行状态分为系统态或用户态两种

- 系统态：(也称管态，内核态)　具有较高的特权，能执行一切的指令，访问所有的寄存器和存储区，传统OS都在系统态运行
- 用户态：(又称目态)　　具有较低的特权的执行状态，仅能执行规定的指令，访问指定的寄存器和存储器

一般情况下，程序只能在用户态执行．不能去执行OS指令即访问OS区域,可以防止应用程序对OS的破坏

大部分OS内核包含以下两大功能：

- 支撑功能

  - 中断处理
  - 时钟管理
  - 原语操作：所谓的原语就是有若干条指令组成的，用于完成一定功能的一个过程. 内核或微核提供核外调用的过程或函数称为原语

- 管理资源功能

  - 进程管理

  - 存储器管理

  - 设备管理

    

#### 进程的创建

##### 进程的层次结构

在OS中允许一个进程创建一个进程，通常把创建进程成为父进程，被创建的进程成为子进程，子进程可以继续创建更多的进程．在进程创建中，子进程可以继承父进程所拥有的资源．进程不能拒绝其子进程的继承权

在widows中不存在进程层次结构，所有进程都具有相同的地位．一个进程创建了另一个进程时，创建过程中获得一个句柄，此句柄就像是一个令牌．可以用来控制被创建的进程．

此句柄只可以传递的，因为在windows中变味了，获得句柄与否，控制与并控制的简单关系

##### 引起创建进程的事件

- 用户登陆　：在分时系统中，系统登陆成功则为用户建立一个进程，并插入就绪队列中
- 作业调度：
- 提供服务：运行的程序发出某种请求后，系统会专门创建一个进程来供用户所需的服务
- 应用请求：这类事件则是由用户进程自己创建新进程，以便与创建进程共同完成任务

##### 进程的创建

- 1.申请空白的PCB，为新进程申请获得唯一的数字标识符，并从PCB集合中索取一个空白的PCB
- 2.为新的进程分配其运行所需的资源，包括物理和逻辑资源．这些资源或从操作系统和父进程获得．新进程对这些资源的需求详情一般会提前告知操作系统或父进程
- 3.初始化PCB：
  - 初始化标识信息
  - 初始化处理机状态信息：使程序计数器指向程序的入口地址，是栈指针指向栈顶
  - 初始化处理机控制信息：将进程的状态设置为就绪状态或静止就绪状态，对于优先级，通常设为最低优先级，除非用户以显式方式提出高优先级要求
  - 如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列

#### 进程的终止

##### 引起进程终止的事件

- 正常结束
- 异常结束：常见异常事件:
  - 越界错：指程序所访问的存储区，以越出改程序的区域
  - 保护错：值进程试图访问不被允许访问的文件资源，或以不正当的方式进行访问
  - 非法指令：指程序试图执行不存在的命令
  - 特权指令错：值程序试图执行一条只允许OS执行的命令
  - 运行超时：
  - 等待超时：
  - 算数算错：指程序试图去执行一个被禁止的运算
  - I/O故障：
- 外界干预：外界请求而终止进程

##### 进程的终止过程

- 1.根据被终止进程的标识符，从PCB集中检索出该进程的PCB，从中读出该进程的状态，
- 2.若被终止的进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真,用于指示该进程被终止后应重新被调度
- 3.若该进程还有子孙进程，则将其子孙进程都终止
- 4.将被终止所拥有的全部资源归还给其父进程，或者归还给系统
- 5.将被终止的进程(PCB)在所在队列中移除，

#### 进程的阻塞与唤醒

##### 引起进程阻塞和唤醒的时间

- 向系统请求共享资源失败
- 等待某种操作完成
- 新数据尚未到达
- 等待新任务的到达

##### 进程阻塞过程

正在执行的过程过，发生了上述时间，进程便通过调用阻塞原语`block` 将自己阻塞 .　由此可见，阻塞是进程自身的一种主动行为.

正在执行的程序首先立即停止执行，

把进程控制块中的现行状态由"执行"改为阻塞，

将PCB插入到阻塞队列，若系统中设置了因不同事件而阻塞的多个阻塞队列，加入相应的阻塞队列即可

##### 进程的唤醒过程

当进程因为某种事件而被阻塞时，，而当所期待的数据已将到达，则有关进程调用唤醒原语`wakeup`，将等待事件的进程唤醒．

首先将阻塞进程从阻塞队列中移除，

将PCB中的现行状态有阻塞改为就绪，

然后再将该PCB插入到就绪队列中

##### 进程的挂起与激活

- 进程的挂起：当系统遇到挂起事件时，OS将利用挂起原语`suspend`将指定的进程或处于阻塞状态的进程挂起．

  - 首先检查被挂起进程的状态，若处于活动就绪，便将其改为静止就绪；对于活动阻塞状态，变改为静止阻塞
  - 为了方便用户或父进程考察该进程的运行情况，，而把该进程的PCB复制到某指定的内存区域
  - 最后，若被挂起的进程正在执行，则转向调度程序重新调度
  
 - 进程的激活过程

   OS将利用激活原语`active`,将指定进程激活，激活的原语现将进程从外存调入内存，检查该进程的现行状态，若是静止阻塞，便将之改为活动阻塞．假如采用的是抢占调度策略，则每当有静止就绪程序被激活而插入就绪队列时，便应检查是否重新调度，即由调度程序将被激活的进程与当前进程两者的优先级进行比较，如果被激活进程的优先级低，就不必重新调度，否则立即剥夺当前进程的运行，把处理机分配给刚刚被激活的进程

   

### 进程同步  

#### 进程同步的概念

进程同步机制的主要任务是：对多个相关进程在执行次序上进行协调，使并发执行的诸多进程之间按照一定的规则(或时序)共享系统资源，并能很好的相互合作，从而是程序执行具有再现性

##### 两种形式的制约关系

- 间接相互制约关系

  多个进程在并发执行的时候，由于共享资源，致使在这些执行的程序之间形成相互制约的关系．为保障这些进程能有序的运行，对于系统中的这类资源必须由系统实施统一分配，即在用户使用之间应当提出申请，而不允许用户直接使用

- 直接相互制约关系

  源于进程之间的合作

##### 临界资源

同一时刻只能被一个进程使用(具体请看`P49`生产者与消费者问题)

##### 临界区

把每个进程中访问临界资源的那段代码成为临界区

在每个进程进入临界区之前应先对欲访问的临界资源进行检查，检查他是否正在被访问，如果没有被访问，进程便可对其临界资源进行访问，并设置他正在被访问的标志．

进入区：在临界区前面增加一段用于进行上述检查的代码

退出去：临界区后加的代码，用于将被访问标志改为未被访问标志

##### 同步机制遵循的规则

- 空闲让进：临界资源为空闲时，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效的利用临界资源
- 忙则等待：临界资源正在被访问时，试图进入临界区的进程必须等待．
- 有限等待：应保证在有限的时间内进入自己的临界区，以免陷入死等状态
- 让权等待：当进程不能进入自己的临界区时，应当立即释放处理机，以免进程陷入＂忙等状态＂

#### 硬件同步机制

利用软件方法解决诸进程进入临界区的问题，但是有一定的难度，并且存在很大的局限性,所以目前的许多计算机提供了一些特殊的硬件指令.

##### 关中断

关中断是是实现互斥最简单的方法之一．

缺点：

- 滥用关中断权利可能导致严重后果
- 关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力
- 不适用与多CPU系统，因为在一个处理器上关中断不能防止进程在其他处理器上执行相同的临界代码

##### 利用`Test-and-Set`指令实现互斥

这是一条借助硬件指令-----"测试并建立"指令`TS`

```c
boolean TS(boolean *lock){
    boolean old;
    old = *lock;
    *lock = TRUE;
    return old;
}
```

##### 利用`Swap`指令实现进程互斥

该指令成为对换指令,每个临界资源设置一个全局的布尔变量`lock `，初始值为`false`，在每个进程中在利用一个局部的布尔变量`key`

```c
void swap(boolean *a  , boolean *b){
    boolean temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
```

#### 信号量机制

##### 整形信号量

定义为一个用于表示资源数目的整型量S，与一般整型量不同，除初始化外，仅能通过两个标准的原子操作来访问

```c
wait(S){
    while(S <= 0){
        S--;
    }
}

signal(S){
    S++;
}
```

##### 记录型信号量

在整型信号量机制中`wait`操作，只要`S<=0`就会不断地测试，因此该机制使进程处于忙等的状态．

记录型信号量机制则是一种不存在"忙等"现象的进程的同步机制.但是又会出现多个进程等待访问同一个临界资源的情况．所以除了用于代表资源数目的整型变量`value`外，还需要一个进程链表指针`list`用来连接上述所有的等待进程

##### `ADN信号量`

​	应用场景一个进程往往需要获得两个即以上的共享资源,当两个进程同时对两个及以上的临界资源进行访问时很容易造成死锁

基本思想：要么将全部的临界资源分配给他，要么一个都不分配

##### 信号量集

对`ADN`信号集机制加以扩充，对进程所申请的所有资源以及每类资源不同的资源需求量，在一次`P,V`原语操作中完成申请和释放．对信号的测试值不在是１，而是该资源的分配下限值ti，要求`si >= ti` , 否则不允许分配.一旦分配，进程对该资源的需求值`di`,即表示资源的占用量，进行`si = si - di`操作.

##### 信号量的应用

- 利用信号量实现进程互斥
  - 设置`mutex`互斥信号量，其初值是１,取值范围为(-1,0,1).当`mutex = 1`时，表示两个进程都没有进入互斥临界区,当`mutex=0`时，表示有一个进程进入临界区运行，另一个必须等待，进入阻塞队列，`当mutex=-1`，表示有一个进程正在临界区运行，另一个进程进程因等待而阻塞在信号量队列中,需要被已在临界区进行执行的进程退出时唤醒.
- 利用信号量实现前趋关系

#### 管程机制

##### 定义：

代表共享资源的数据结构以及对该共享数据结构实施操作的一组过程所组成的资源管理程序共通构成了一个操作系统的资源管理模块.

##### 组成

- 管程的名字
- 局部于管程的共享数据结构说明
- 对该数据结构进行操作的一组过程
- 对局部于管程的共享数据设置初始值的语句

##### 特性

- 模块化:是一个基本的程序单位，可以单独编译
- 抽象数据类型:管程中不仅有数据，还有对数据的操作．
- 信息掩蔽：管程中的数据结构只能由管程中的过程访问这些过程是管程内部定义的，供外部的进程调用

##### 条件变量

解决当一个进程进入管程却又被阻塞会被挂起，导致其他进程被迫长时间进行等待

通常被阻塞或者被挂起的条件可有很多个，因此在管程中设置多个条件变量相互对应,每个条件变量保存了一个链表，用来记录应该条件而阻塞的所有进程，同时提供`x.wait和x.signal`

- `x.wait`：正在调用管程的进程因x条件需要被阻塞或被挂起；则调用`x.wait`将自己插入到x条件的等待队列上，并释放进程，直到x条件发生了变化．
- `x.signal`：正在调用管程的进程因x的变化需要被阻塞或被挂起，则调用`x.signal`，重新启动ｘ链表上的进程，并释放管程，如果ｘ链表中没有进程则继续执行原有进程





### 进程通信

- 进程的通信应当利用OS提供的高级通信工具，主要由如下特点:
  - 使用方便:OS隐藏了实现进程进程通信的具体细节，向用户提供了一组用于实现高级通信的命令(原语),用户可直接利用它实现进程间的通信．
  - 高效的传送大量数据：用户可直接利用高级通信命令(原语)高效的传送大量数据

##### 进程通信的类型

###### 共享存储器系统

- 基于共享数据结构的通信方式：要求诸进程公用某些数据结构，借以实现进程间的信息交换
- 基于共享存储区的通信方式：为传输打来那个数据，在内存中划出一块共享的存储区域，通过读写交换信息，应为数据的形式和位置都是由进程负责，所以这属于高级通信

###### 管道通信系统：

所谓"管道"及时连接一个读进程和一个写进程以实现通信的一个共享文件，又名`pipe`文件.以字符流的形式进行数据传输．为协调双方通信，必须提供以下三方面协调能力：

- 互斥：即当一个进程对文件进程操作时，另一个进程应当等待
- 同步：指当输入进程把一定数量的数据写入文件时，便进行等待睡眠，直至输出进程取走数据后在将其唤醒，当输出进程读取空文件时，也应当睡眠，等待输入进程写入完成后将其唤醒．
- 确认对方是否存在

- 消息传递机制：以格式化的消息为单位，将通信数据封装在消息中，并利用操作系统提供的一组通信命令，在进程之间进行消息传递，完成进程数据交换.例如：在计算机网络中，消息又称为报文，在微内核操作系统中，微内核与服务器之间通信无一例外都是采用了消息传递机制

  - 直接通信方式：利用OS原语，直接将消息发送给目标进程
  - 简介通信方式：指发发送和接受进程，都是通过共享中间实体(称为邮箱)的方式进行消息的发送和接受

###### 客户机-服务器系统:

- 套接字：起源于20世纪70年代加州伯克利分校版本的`UNIX(即BSD Unix)`，以逐渐成为最流行的网络通信程序接口之一.一个套接字就是一个通信标识类型的数据结构，其中包括：

  - 通信的目的地址
  - 通信实用的端口号
  - 通信网络的传输层协议
  - 进程所在的网络地址
  - 以及针对客户或服务器程序提供的不同系统调用(或`API`函数)
- 套接字包括两类:

  - 基于文件型：通信进程运行于同一台机器时，套接字是基于本地的文件系统支持的，一个套接字关联到一个特殊的文件，通信进程通过这个特殊的文件读写实现通信，类似管道．
  - 基于网络型：该类型通信双方运行在不同主机的网络环境下，通常采用的是非对称方式通信.一个属于发送进程(客户端),一个属于接受进程(服务端)
    - 一般客户端发送请求，随机申请一个套接字，主机为之分配一个端口，与该套接字绑定，不在分配给其他进程．
    - 服务端拥有全局公认的套接字和指定的端口(如`ftp`服务器监听端口为21,`Web或http`服务器监听端口为80)，通过监听端口等待客户端请求．
    - 通信结束时，系统通过关闭服务端的套接字撤销连接

- 远程过程调用和远程方法调用：远程过程(函数)调用`RPC(Remote Procedure Call)`，是一个通信协议,用于通过网络连接的系统.该协议允许运行于一台主机(本地)系统上的进程调用另一条主机(远程)系统上的`RPC`．引入一个存根的概念：在本地客户端，每个能独立运行的远程过程都拥有一个客户存根，本地进程调用远程进程过程实际是调用该过程关联的存根；服务端也有服务器存根，存根一般处于阻塞状态．等待消息．主要步骤如下：

  ![](/home/ls/桌面/class/studyMore/操作系统/img/20160630-cs-rpc.png)

  ![](/home/ls/桌面/class/studyMore/操作系统/img/20160630-lpc.png)

  - 调用远程过程在本地关联的客户端存根，传递相应的参数，然后将控制权全给客户存根

    - ```c
      //以c语言为栗子
      /*
      **fd 为一个整型数，表示一个文件。buf 为一个字符数组，用于存储读入的数据。 nbytes 为另一个整型数，**用于记录实际读入的字节数
      */
      /*
      *当read是一个远程过程的时候，他就是以个客户存根,过程同样遵循上述图中(b)的过程，但是不要求操作系统提供数据．而是打包消息，请求发送给服务端
      */
      count = read(fd, buf, nbytes);
      ```

  - 客户存根执行，完成包括过程名和调用参数等信息的建立，将控制权移交给本地客户进程

  - 本地客户进程完成与服务器的消息传递，将消息发送到远程服务器进程

  - 消息到达服务器之后，由操作系统转交给服务器存根．

    - 服务器存根：与客户端存根等价，也是一段代码．用来将网络输入的请求转化为本地过程调用

  - 然后服务器存根会调用`receive`,然后被阻塞，等待消息输入

  - 收到消息后，服务器将将参数由消息中取出，然后以常规方式调用服务器上相应的过程

    - 以服务端的角度来看，过程好像是由客户端直接调用一般：参数和返回地址都在堆栈中，服务器执行所要求的操作，然方会给调用方．
    - 以上面的`read`为栗子，服务器将用数据填充第二个指针所对应的缓冲区，缓冲区在属于服务器存根内部

  - 服务器的远程过程运行完毕之后，将结果返回给与之关联的服务器存根

  - 服务器存根将消息打包，将控制权转移给远程服务进程

  - 远程服务器进程将消息发送回给客户端

  - 本地客户端收到消息后，根据其中的过程名将消息存入关联的的客户存根．在将控制权移交给客户存根

   -  客户存根从消息中取出结果后，返回给本地调用进程，并移交控制权



##### 消息传递通信的实现方式

###### 直接消息传递方式

采用直接通信方式，即发送进程利用OS所提供的发送命令(原语)，直接将消息发行给目标进程

- 直接通信原语

  - 对称寻址方式：要求发送与接受进程都必须显示提供对方的标识符

  - ```c
    send(receiver , message);                                        //发送一个消息给接受进程
    receive(sender  , message)                                     //接受Sender发来的消息
    ```

  - 不足之处在于：一旦改变进程的名称，则可能需要检查所有进程的定义，有关对进程旧名称的所有引用必须查到，以便将他修改为新名称

- 非对称寻址方式：接受进程可能需要与多个发送进程通信，无法实现指定发送进程．相比于直接寻址方式，在接收原语中，不需要命名发送进程，只填写表示源进程的参数，即完成通信的返回值．而发型进程仍需要命名接收进程

- ```c
  send(P , message);                                  //发送一个消息给进程P
  receive(id , message)                             //接收来自任何进程的消息，id变量可设置为进行通信的发送方进程id或名字
  
  ```

###### 消息的格式

###### 进程的同步方式

- 发送进程阻塞，接收进程阻塞：主要用于进程之间紧密同步，发送进程与接收进程之间无缓冲
- 发送进程不阻塞，接收进程阻塞：发送进程不阻塞，因而他可以尽快地把一个或多个消息发送给多个目标，而接收进程在消息来的时候被唤醒
- 发送进程与接收进程均不阻塞

###### 通信链路

为使通信的进程之前能够通信，必须为两者建立一条通信链路,有两种方式建立通信链路：

- 由发送进程在通信之前用显示的"建立连接"命令原语请求系统为之建立一条通信链路，在链路使用完毕之后拆除．主要用于计算机网络
- 发送进程无需提出建立链路的请求，只需要利用系统提供的发送命令(原语),系统会自动为之建立一条链路．主要用于单机系统

根据通信方式的不同将链路分为两种：

- 单向通信链路：只允许一方发送消息
- 双向通信链路：
- 多点连接链路

###### 信箱通信

属于间接通信方式，即进程通信，需要通过某个中间实体．该实体建立在随机存储器的公用缓冲区上，用来暂存发送的消息．把这种中间实体称为邮箱，邮箱都有一个唯一的标识符．消息在邮箱中可以安全的存储，只允许核准的目标用户进行读取．因此，邮箱既可以用来实现实时通信也可以是非实时通信

- 信箱的结构：

  - 信箱头：用于存放有关信箱的描述信息，如：信箱标识符，信箱的拥有者，信箱口令和信箱空格数等
  - 信箱体：由若干个可以存放消息(或消息头的信箱格组成)，信箱格的数目以及信箱格大小在创建时其确定的

- 信箱通信原语：

  - 邮箱的创建于撤销：进程可利用邮箱创建原语来建立一个新邮箱，创建时应给出邮箱名字，邮箱属性(公用，私用或共享);对于共享邮箱，还应给出共享者的名字，在进程不在需要读取邮箱时，可用邮箱撤销原语将其撤销

  - 消息的发送和接受

    - ```c
      Send(mailbox , message)                                //将一个消息发送到指定邮箱
       Receive(mailbox , message)                         //从指定邮箱中接受一个消息
      ```

    - ![](/home/ls/桌面/class/studyMore/操作系统/img/v2-68145d8fdfb926c5fa1b3101b6834b5e_hd.jpg)

- 邮箱的类型

  - 私有邮箱
  - 公用邮箱
  - 共享邮箱

###### 直接消息传递系统实例

![](/home/ls/桌面/class/studyMore/操作系统/img/v2-91e7db4eaba2b81dd5fb7a35bab50846_hd.jpg)

![](/home/ls/桌面/class/studyMore/操作系统/img/1386ab2fb1c028d0296e0acc0bf46766.png)

- 消息缓冲队列通信机制中的数据结构

  - 消息缓冲区:

    - ```c
      typedef struct message_buffer{
          int  sender;                    //发送者进程标识符
          int  size;　　　　　　//消息长度
          char *text;                     //消息正文
          struct message_buffer *next;            //指向下一个消息缓冲区的指针
      }
      ```

  - PCB中有关通信的数据项，　还用在进程的PCB中增加消息队列队首指针，用于对消息队列的操作．还应该添加实现同步的互斥信号量`mutex`,资源信号量`sm`

    - ```c
      typedef  struct processcontrol_block{
          ...
          struct message_buffer *mq;          //消息队列队首指针
          semaphone mutex;                           //消息队列互斥信号量
          semaphone sm;                                 //消息队列资源信号量
      }PCB;
      ```



### 线程

#### 线程的引入

为了减少程序在并发运行时所付出的时空开销，使OS能有更好的并发性

##### 进程的两个基本属性

- 进程是一个可以拥有资源的独立单位，一个进程要能够独立运行，则必须拥有一定的资源．＼
- 进程同时也是一个可独立调度和分派的基本单位．

##### 程序并发执行所需付出的时空开销

- 创建进程：系统在创建进程是必须为其分配必须的资源，如：内存空间，I/O设备，以及建立相应的PCB
- 撤销进程：系统撤销进程时又必须回收其占用的资源
- 进程切换：进程上下文切换时，需要保留当前的CPU环境，设置新的进程的CPU环境，因而需要花费不少处理机的时间(时间片切换话费时间的原因)

##### 线程------作为调度和分派的基本单位

#### 线程进程的比较

线程具有许多传统进程所具有的特征，所以成为轻型进程

##### 调度的基本单位

线程作为调度和分派的基本的单位，而进程为资源分配的基本单位．

##### 并发性

在引入线程的OS中，不仅进程之间可以并发，线程之间也可以，甚至一个进程中所有的线程一起并发．不同进程之间的线程亦可以进行并发．使得系统拥有更好的并发性，从而更加有效的提高系统资源的利用率和系统的吞吐量

##### 拥有资源

进程可以拥有资源，并作为系统中拥有资源的一个基本单位．可以访问到隶属进程的资源．每个线程都有一个用于控制用于控制线程运行的线程控制块	`TCB`	，用于指示被执行指令序列的程序计数器，保留局部变量，少数状态资源和返回地址等的一组寄存器和堆栈．

##### 独立性

同一进程中线程往往是为了提高并发性以及进行相互之间的合作而创建的，它们共享进程的内存地址空间和资源，比如每个线程可以访问他们所属进程地址空间中的所有地址，如一个线程中的堆栈可以被其他的线程读，写设置被清除．

##### 系统开销

线程的切换仅需保存和设置少量寄存器内容．由于一个进程中的多个线程具有相同的地址，因此，在一些OS中，线程切换，同步和通信都无需系统的内核的干预

##### 支持多处理机系统

对于多线程进程，就可以将一个进程中的多个线程放在多个处理机上使他们并行．

#### 线程的状态与线程控制块

##### 线程运行的三个状态：

- 执行态
- 就绪态
- 阻塞状态

##### 线程控制块`TCB`

- 线程标识符

  - 一组寄存器，包括程序计数器`PC`状态寄存器和通用寄存器的内容

  - 线程的运行状态

  - 优先级

  - 线程的专有存储区：用于线程切换时存储现场数据

  - 信号屏蔽：对某些信号加以屏蔽

  - 堆栈指针：保存局部变量和返回地址，在`TCB`中，也必须设置两个指针指向堆栈

    - 指向用户自己堆栈的指针和指向核心栈的指针
      - 前面应该是指线程运行的用户态，使用用户的用户栈来保存局部变量和返回地址
      - 后者应该是指当前线程运行在核心态是使用的系统核心态

    


##### 多线程OS中的进程属性

-  进程是一个可拥有资源的基本单位
- 多个线程可并发执行
- 进程已不再是可执行的实体



### 线程的实现

####　线程的实现方式

##### 内核支持线程`	KST`

在OS中的所有的进程，无论是系统进程还是用户进程，都是在操作系统内核的支持下运行的，与内核紧密相关.而内核支持线程`	KST`同样也是在内核的支持下运行，包括线程的创建，阻塞，撤销和切换等.

优点:

- 在多处理器系统中，内核能够同时调度一个进程中的多个线程并行执行
- 若进程的线程被阻塞，内核可以调度该进程中其他线程占用处理机，也可以调度其他进程中的线程
- 内核支持线程具有很小的数据结构和堆栈，线程切换的速度较快，切换开销小
- 内核本身采用的是多线程技术，可以提高系统的执行速度和效率

缺点:

- 对于用户的线程切换而言，切换开销较大，在一个进程中从一个线程切换到另一个线程时，需要从用户态转到核心态．这是因为用户进程是在用户态运行的，而线程调度和管理实在内核实现的，系统开销较大

##### 用户级线程

用户级线程实在用户空间的中实现的，对线程创建，撤销，同步与通信等功能都无需内核的支持．

用户级线程的调度仍是以进程为单位进行的，而在内核支持线程中是以线程为单位进行调度的

优点：

- 线程切换不需要转换到内核空间．在一个进程中，其所有的线程管理数据结构均在该进程的用户空间中，不必切换模式
- 调度算法可以是线程专用的．在不干扰OS的情况下，进程可以根据自身需要选择不同的调度算法
- 用户级线程与OS无关，应而对于线程管理的代码是属于用户程序的一部分，所有的应用程序都可以与之共享

缺点：

- 系统调用的阻塞问题：在基于进程的OS中，大多数的系统调用将使进程堵塞．因此，当线程执行一个系统调用时，不仅该线程会被堵塞，这个进程中的所有的线程都会被阻塞，而在内核支持线程中，则进程中的其他线程可以运行．(这个的主要区别在于上面提到的内核支持的线程调度单位是线程，而用户级线程的调度的单位是进程)
- 在单纯的用户级线程实现方式中，多线程应用不能利用多处理机进行多重处理的优点

##### 组合方式

有些OS将用户级线程和内核支持线程两种方式进行组合，组合方式线程中，同一个进程中的多个线程可以同时在多处理机上并行执行，而阻塞线程并不用阻塞进程

- 多对一模型：即将用户线程映射到一个内核控制线程．仅当用户线程需要访问内核时，才会将其映射到内核进程上，但每次只允许一个线程进行映射．一般用户线程属于同一个进程，线程的管理和控制都是在进程中的.
  - 优点：线程管理开销小，效率高，
  - 缺点：如果一个线程访问内核时阻塞，整个进程都会被堵塞，此外，只有一个线程访问内核，多个线程不能同时在多个处理机上运行
- 一对一模型：
  - 优点：当一个进程阻塞是运行调运另一线程进行执行，允许多个线程并发运行在多个处理机上
  - 缺点：每创建一个用户线程，就需要创建一个内核线程，开销较大，因而需要限制整个系统的的线程数
- 多对多模型：即将许多的用户进程映射到同样数量或者更少的内核线程上

![](/home/ls/桌面/class/studyMore/操作系统/img/download.jpg)



## 第三章 处理机调度与死锁

### 处理机调度的层次和调度算法的目标

#### 处理机调度层次

##### 高级调度

又称为长进程调度或作业调度，他调度对象是作业．其主要的功能是根据某种算法，决定将外存上处于后备队列中的那个作业调入内存，为他们创建进程，分配必要的资源，并将他们放入就绪队列．

高级调度主要用于多道批处理系统，而在分时和实时系统中不设置高级调度

##### 低级调度

又称为进程调度或短程调度,其调度对象是进程(或内核级线程)

主要功能：根据某种算法，决定就绪队列中那个进程应获得处理机．并由分派程序将处理机分配给被选中的进程．

进程的调度是最基本的一种调度．

在多批道，分时，和实时三种类型的OS中，都必须配置这种调度

##### 中级调度

又称内存调度，引入中级调度的原因是提高内存利用率和系统的吞吐量，为此，应把那些暂时不能运行的进程，调至外存等待，此时进程状态被称为就绪驻外存状态(挂起状态),当它们已具备运行条件且内存空闲时，由中级调度来决定，把外存上哪些具备运行条件的就绪进程再重新调入内存，并修改为就绪状态，挂在就绪队列上等待．

中级调度实际上是存储器管理中的对换功能．

调度的等级根据他们所执行的频率和所花费的时间进行命名的

#### 处理机调度算法的目标

#####　处理机调度算法的共同目标

- 资源利用率

$$
CPU的利用率 =  CPU有效的工作时间/(CPU有效工作时间+CPU空闲等待时间)
$$

- 公平性：应使诸进程都获得合理的CPU时间，不会发生进程饥饿现象．
- 平衡性：在系统中有各种类型的进程，为使系统的CPU和各种外部设部都能处于忙碌状态，调度算法应当尽可能保持系统资源实用的平衡性
- 策略强制执行：所制定的策略包括安全策略，只需要，就必须予以准确的执行，即使造成某些工作的延迟也要执行

##### 批处理系统的目标

- 平均周转时间短：

  - 周转时间：是指从作业被提交给系统开始，到作业结束为止的时间间隔(称为作业周转周期),其中包括四部分时间：

    - 作业在外存后备队列上等待的时间调度的时间

    - 进程在就绪队列上的等待时间

    - 进程在CPU上执行时间

    - 以及等待I/O操作完成时间

    - 为了进一步的反应性能，往往使用带权周期时间

      - T代表周转时间，TS代表系统提供服务的时间
        $$
        W = T / TS             
        $$

        $$
        w = (W1+W2+...+Wn)/n
        $$

  - 系统的吞吐量：吞吐量是指单位时间内系统所完成的作业数

  - 处理机的利用率：

- 分时系统的目标

  - 响应时间快：响应时间是指用户通过键盘提交一个请求开始，直到屏幕显示出处理结果为止的一段时间间隔，包括：
    - 请求信息从键盘输入开始，直至将其传送到处理机的时间
    - 处理机对请求信息进行处理的时间
    - 将所有相应信息回到终端显示器的时间
  - 均衡性：指系统的响应时间的快慢应与用户请求服务的复杂性相适应

- 实时系统的目标

  - 截止时间保证．
    - 截止时间：是指某任务必须开始执行的最迟时间，或必须完成的最迟时间．
    - 对于`HRT`(硬实时)任务，其调度方式和调度算法必须确保对截止时间的要求
      - 对于`SRT`(软实时)任务，其调度方式和调度方法也基本上能保证对截止时间的要求
  - 可预测性



###　作业与作业调度





​    



















